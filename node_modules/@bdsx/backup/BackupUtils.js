"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackupUtils = void 0;
const fs_1 = require("fs");
const fs = require("fs");
const path_1 = require("path");
const util_1 = require("util");
const AdmZip = require("adm-zip");
const ncp = require("ncp");
class BackupUtils {
    static async getWorldName(bedrockServerPath) {
        return BackupUtils.readFile(`${bedrockServerPath}/server.properties`)
            .then((data) => {
            const reg = /^level-name=(.+)/gim;
            const matches = (data.match(reg) || []).map((e) => e.replace(reg, "$1"));
            return matches ? matches[0].trim() : "Unknown";
        })
            .catch((err) => {
            console.log(`Failed to read ${bedrockServerPath}/server.properties ${err}`);
            return "Unknown";
        });
    }
    static async readFile(path) {
        return await fs_1.promises.readFile(path, "utf8");
    }
    static async removeDirectory(path) {
        if (!(await BackupUtils.directoryExists(path))) {
            return;
        }
        const removeEmptyFolder = (path) => {
            return fs_1.promises.rmdir(path).catch((err) => {
                console.log(`Failed to remove ${path}: ${err}`);
            });
        };
        return fs_1.promises.lstat(path).then((stats) => {
            if (stats.isDirectory()) {
                return fs_1.promises
                    .readdir(path)
                    .then((files) => Promise.all(files.map((file) => BackupUtils.removeDirectory(path_1.join(path, file)))))
                    .then(() => removeEmptyFolder(path));
            }
            else {
                return fs_1.promises.unlink(path).catch((err) => {
                    console.log(`Failed to remove ${path}: ${err}`);
                });
            }
        });
    }
    static async directoryExists(filePath) {
        return new Promise((resolve) => {
            fs_1.promises.access(filePath)
                .then(() => {
                resolve(true);
            })
                .catch(() => {
                resolve(false);
            });
        });
    }
    static async createTempDirectory(worldName, handleError, tempName) {
        const now = new Date(Date.now());
        const addLeadingZero = (value) => {
            return `0${value}`.slice(-2);
        };
        const getTime = (date) => {
            return addLeadingZero(date.getHours()) + addLeadingZero(date.getMinutes()) + addLeadingZero(date.getSeconds());
        };
        const timeStamp = [now.getFullYear(), addLeadingZero(now.getMonth() + 1), addLeadingZero(now.getDate()), getTime(now)].join("-");
        const directory = tempName ? `temp/${tempName}` : `temp/${timeStamp}`;
        await BackupUtils.ensureDirectoryExists(`${directory}/${worldName}`, handleError);
        return directory;
    }
    static async removeTempDirectory(tempDirectory) {
        await BackupUtils.removeDirectory(tempDirectory).catch((err) => {
            console.log(`Failed to remove ${tempDirectory}: ${err}`);
        });
    }
    static async truncate(file, tempDirectory) {
        const truncateFile = util_1.promisify(fs.truncate);
        const [filePath, bytesCount] = file.split(":");
        await truncateFile(`${tempDirectory}/${filePath}`, Number(bytesCount)).catch((err) => {
            console.log(`Failed to truncate ${filePath}: ${err}`);
        });
    }
    static async zipDirectory(backupsPath, tempDirectory, worldName, handleError) {
        const destination = `${backupsPath}/${path_1.basename(tempDirectory)}_${worldName}.zip`;
        await BackupUtils.ensureDirectoryExists("backups", handleError);
        await new Promise((resolve) => {
            const zip = new AdmZip();
            zip.addLocalFolder(`${tempDirectory}/${worldName}`);
            zip.writeZip(destination, (err) => {
                if (err) {
                    handleError("Failed to create zip");
                    resolve(false);
                }
                console.log(`Saved to ${destination}`);
                resolve(true);
            });
        });
    }
    static async moveFiles(worldsPath, tempDirectory, worldName, handleError) {
        await new Promise((resolve) => {
            ncp(`${worldsPath}/${worldName}`, `${tempDirectory}/${worldName}`, {
                filter: (source) => {
                    return source.indexOf("lost") === -1;
                },
            }, (err) => {
                if (err) {
                    handleError(`${err}`);
                    resolve(false);
                }
                resolve(true);
            });
        });
    }
}
exports.BackupUtils = BackupUtils;
BackupUtils.ensureDirectoryExists = async (filePath, handleError) => {
    if (!(await BackupUtils.directoryExists(filePath))) {
        await fs_1.promises.mkdir(filePath, { recursive: true }).catch((err) => {
            if (err.indexOf("EEXIST:") === -1) {
                handleError(`Failed to create directory: ${filePath}: ${err}`);
            }
        });
    }
};
//# sourceMappingURL=BackupUtils.js.map